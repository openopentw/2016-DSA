// 2.1
// (1)
float tmp;
for(int i = 0; i != n; ++i) {
	for(int j = 0; j != i; ++j) {
		tmp = M[i][j];	M[i][j] = M[j][i];	M[j][i] = tmp;
	}
}

// (2)
// code:
// type A[n][n]
type T[n * (n + 1) / 2];
type *ptr;
// store method:
T[i * (i - 1) + j] = A[i][j]	// i >= j
// memory layout: 
--------------------------------------------------------------------------------------------------------------------------------------------------------
| A[0][0] | A[1][0] | A[1][1] | A[2][0] | A[2][1] | ...... | A[i][0] | A[i][1] | A[i][2] | ...... | A[i][i] | A[i+1][0] | A[i+1][1] | ...... | A[n][n] |
--------------------------------------------------------------------------------------------------------------------------------------------------------
// getting

// putting


// 2.2
// (1)
(1) accept :
事先依照 user, item, time 的順序 sort 好資料，存在 vector Dacc 裡面，以後每次找資料的時候，都用二分搜尋法，也是依照 user, item, time 的順序搜尋。
我覺得會有效率的原因是因為，當一個資料庫建好之後，每次搜尋都能用到接近 O(N)=log(N) 的二分搜尋法
而且一個資料庫建好後，不只是這一個函式可以使用，其他的很多函式就可以很方便的取用、複製，不用再建一遍
(2) items :
直接複製 (1) 的資料結構，然後依照 user, item 的順序做 unique，

輸出資料時，就不用再判斷重複的問題了
